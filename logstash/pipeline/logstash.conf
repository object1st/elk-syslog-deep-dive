# Enhanced Logstash Configuration
# Builds on the basic setup from Blog Part 2 but adds intelligent parsing
# for Veeam malware detection and OOTBI storage monitoring

input {
  # Keep original TCP input for JSON logs
  tcp {
    port => 5000
    codec => json_lines
    tags => ["tcp"]
  }
  
  # Enhanced syslog input with better parsing
  syslog {
    port => 5514
    tags => ["syslog"]
  }
}

filter {
  # Only process syslog messages
  if "syslog" in [tags] {
    
    # Basic application detection (enhanced from original)
    if [program] =~ /(?i)veeam/ {
      mutate {
        add_field => { 
          "source_type" => "veeam" 
          "category" => "backup"
          "vendor" => "veeam"
          "app_type" => "veeam"
        }
      }
    }
    else if [program] =~ /(?i)ootbi/ or [message] =~ /(?i)ootbi/ {
      mutate {
        add_field => { 
          "source_type" => "ootbi"
          "category" => "storage" 
          "vendor" => "object_first"
          "app_type" => "ootbi"
        }
      }
    }
    else {
      mutate {
        add_field => { "app_type" => "unknown" }
      }
    }

    # ENHANCED VEEAM PARSING
    if [app_type] == "veeam" {
      
      # Keep original job parsing but enhance it
      if [message] =~ /Job \[/ {
        grok {
          match => { "message" => "Job \[%{DATA:job_name}\]" }
        }
      }
      
      # Enhanced status detection (from original)
      if [message] =~ /Success/ {
        mutate { 
          add_field => { 
            "backup_status" => "success"
            "severity" => "info"
            "business_impact" => "low"
          }
        }
      } 
      else if [message] =~ /Warning/ {
        mutate { 
          add_field => { 
            "backup_status" => "warning"
            "severity" => "warning"
            "business_impact" => "medium"
          }
        }
      } 
      else if [message] =~ /Error|Failed/ {
        mutate { 
          add_field => { 
            "backup_status" => "error"
            "severity" => "error"
            "business_impact" => "high"
          }
        }
      }

      # NEW: Advanced Veeam Malware Detection Parsing
      if [message] =~ /\[origin enterpriseId=/ {
        grok {
          match => {
            "message" => "\\[origin enterpriseId=\"%{DATA:enterprise_id}\"\\] \\[categoryId=%{INT:category_id} instanceId=%{INT:instance_id} DetectionTimeUTC=\"%{DATA:detection_time}\" OibID=\"%{DATA:oib_id}\" ActivityType=\"%{DATA:activity_type}\" UserName=\"%{DATA:username}\" ObjectName=\"%{DATA:object_name}\" VbrHostName=\"%{DATA:vbr_hostname}\" Description=\"%{GREEDYDATA:description}\"\\]"
          }
          add_tag => ["veeam_malware_parsed"]
        }
        
        # Extract domain and username
        if [username] {
          grok {
            match => {
              "username" => "(?<user_domain>[^\\\\]+)\\\\(?<clean_username>.+)"
            }
          }
        }
        
        # Convert numeric fields
        if [category_id] {
          mutate { convert => { "category_id" => "integer" } }
        }
        if [instance_id] {
          mutate { convert => { "instance_id" => "integer" } }
        }
        
        # Malware threat intelligence
        if [instance_id] and [instance_id] == 41600 {
          mutate {
            add_field => { 
              "event_category" => "security"
              "event_type" => "malware_detection"
              "alert_priority" => "immediate"
            }
          }
          
          if [activity_type] == "EncryptedData" {
            mutate {
              add_field => { 
                "severity" => "critical"
                "threat_type" => "ransomware_indicator"
                "business_impact" => "critical"
                "recommended_action" => "isolate_system"
              }
            }
          }
          else if [activity_type] == "RansomwareExtensions" {
            mutate {
              add_field => { 
                "severity" => "critical"
                "threat_type" => "ransomware_confirmed"
                "business_impact" => "critical"
                "recommended_action" => "immediate_isolation"
              }
            }
          }
        }
      }
    }

    # NEW: OOTBI PARSING
    if [app_type] == "ootbi" {
      # Parse OOTBI structured event data
      if [message] =~ /\[ootbi_event@61062/ {
        grok {
          match => {
            "message" => "\\[ootbi_event@61062 Node=\"%{DATA:node_name}\" NodeId=\"%{DATA:node_id}\" DateTime=\"%{DATA:event_datetime}\" Source=\"%{DATA:source}\" EventId=\"%{INT:event_id}\" ProductVersion=\"%{DATA:product_version}\" EDataVersion=\"%{DATA:edata_version}\"\\]\\s*%{GREEDYDATA:event_message}"
          }
          add_tag => ["ootbi_parsed"]
        }
        
        if [event_id] {
          mutate { convert => { "event_id" => "integer" } }
        }
        
        # OOTBI intelligence
        if [event_id] and [event_id] >= 2510 and [event_id] <= 2520 {
          mutate {
            add_field => { 
              "event_category" => "storage"
              "event_type" => "capacity_warning"
            }
          }
          
          if [event_message] =~ /less than 20%/ {
            mutate { 
              add_field => { 
                "severity" => "critical"
                "business_impact" => "high"
                "alert_priority" => "immediate"
              }
            }
          }
          else if [event_message] =~ /less than 40%/ {
            mutate { 
              add_field => { 
                "severity" => "warning"
                "business_impact" => "medium"
                "alert_priority" => "standard"
              }
            }
          }
        }
        else {
          mutate {
            add_field => { 
              "event_category" => "general"
              "event_type" => "general"
              "severity" => "info"
              "business_impact" => "low"
            }
          }
        }
      }
    }
  }
  
  # Handle parsing failures gracefully
  if "_grokparsefailure" in [tags] {
    mutate {
      add_field => { 
        "parsing_status" => "failed"
        "parsing_error" => "grok_pattern_mismatch"
      }
      add_tag => ["parsing_failure"]
    }
  }
  else {
    mutate {
      add_field => { "parsing_status" => "success" }
    }
  }
  
  # Keep original processed_by field
  mutate {
    add_field => { "processed_by" => "logstash" }
  }
}

output {
  # Enhanced output routing
  if [parsing_status] == "failed" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "parsing-failures-%{+YYYY.MM.dd}"
    }
  }
  else if [source_type] == "veeam" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "veeam-logs-%{+YYYY.MM.dd}"
    }
  }
  else if [source_type] == "ootbi" {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "ootbi-logs-%{+YYYY.MM.dd}"
    }
  }
  else {
    elasticsearch {
      hosts => ["http://elasticsearch:9200"]
      index => "logs-%{+YYYY.MM.dd}"
    }
  }
  
  # Debug output (uncomment for troubleshooting)
  # stdout { codec => rubydebug }
}
